#include "../src/contract.jsligo"
#include "./mock_rollup.jsligo"
#include "./fa12.jsligo"

//util function
let assert_failure = ([result,message] : [test_exec_result,string]) : bool => {
    return match(result,{
      Success: (_ : nat) => false,
      Fail: ( tee : test_exec_error ) => 
        match(tee,{
          Other: () => false, 
          Rejected: (s:[michelson_program , address])=>{  Test.log (["expected error : ", message, " Actual : "]) ; Test.log(s[0]) ; return ((Test.eval(message)) == s[0]) } }) 
      })
    };
    
    // reset state
    let _reset = Test.reset_state ( 10 as nat, list([]) as list <tez> );
    let faucet = Test.nth_bootstrap_account(0);
    let sender1 : address = Test.nth_bootstrap_account(1);
    let log_0 = Test.log("Sender 1 has balance : ");
    let log_1 = Test.log(Test.get_balance(sender1));
    let sender2 : address = Test.nth_bootstrap_account(2);          
    let log_2 = Test.log("Sender 2 has balance : ");
    let log_3 = Test.log(Test.get_balance(sender2));

    let _setbaker = Test.set_baker(faucet);
    let _setsource = Test.set_source(faucet);
  
  
  //mock rollup origination
  let [trollupaddr, _, _] = Test.originate(rollupMain, Map.empty as map<address,ticket<bytes>>, (0 as tez));
  let rollupContr = Test.to_contract(trollupaddr);
  let rollupAddress = Tezos.address(rollupContr);
  let log_4 = Test.log("rollup contract deployed with values : ");
  let log_5 = Test.log(rollupContr);

  //fa1.2 origination
  let [tfa12addr, _, _] = Test.originate(fa12Main, 
    {tokens      : Big_map.empty as big_map<address,nat>,
     allowances  : Big_map.empty as big_map<[address,address],nat>,
     total_amount : 4200 as nat},
    (0 as tez));
  let fa12Contr = Test.to_contract(tfa12addr);
  let fa12Address = Tezos.address(fa12Contr);
  let log_6 = Test.log("fa12 contract deployed with values : ");
  let log_7 = Test.log(fa12Contr);

  //contract origination
  let [taddr, _, _] = Test.originate(main, unit, (0 as tez));
  let contr = Test.to_contract(taddr);
  let log_8 = Test.log("contract deployed with values : ");
  let log_9 = Test.log(contr);
  
  // FUNCTIONS
  
  let _testDeposit = ([s,depositOp,XTZToCheck] : [address,depositOp,nat]) : bool => {
    Test.set_source(s);
    let status = Test.transfer_to_contract(contr, (Deposit(depositOp)), XTZToCheck * (1 as tez));
    Test.log(status);
    //FIXME, we cannot decompile a ticket =>  let rollupStore : rollupStorage = Test.get_storage(trollupaddr); 
    let rollupStore : michelson_program = Test.get_storage_of_address(rollupAddress); 
    Test.log(rollupStore);

    Test.log (["expected XTZToCheck : ", XTZToCheck]) ;
    Test.log (["actual ticket qty for inbox rollup : ","LOOK MANUALLY ABOVE"]) ;

    let l2adr = match(depositOp , {
      XTZ_OP : (xtzOp:xtzOp) => {
        assert(Test.get_balance(Tezos.address(contr)) ==  XTZToCheck * (1 as tez)) ; 
        assert(Test.get_balance(s) <= (( abs(4_000_000-XTZToCheck)) * (1 as tez )));   
        return xtzOp.l2Address},
      FA12_OP : (fa12Op:fa12Op) => fa12Op.l2Address
    });
    
    //BUGGY assert(Test.michelson_equal(  Test.compile_value(Map.add(l2adr,Tezos.create_ticket(Bytes.pack(XTZ()),amountToCheck),Map.empty)) , rollupStore ));
    
    //RESULT SHOULD BE : `{ Elt "tz1KeYsjjSCLEELMuiq1oXzVZmuJrZ15W4mv"(Pair "KT1HNXPPphKMWVgiYBxAAbjFUuUWbrP7CGBf" 0x050508030b 42) }` 

    /*  It has to be a manual check

    let [[addr, [v, amt]], tic] : read_ticket_return = Tezos.read_ticket(Option.unopt(Map.find_opt(l2adr,rollupStore)));    
    assert( amt == amountToCheck);
    Test.log (["expected amountToCheck : ", amountToCheck]) ;
    Test.log (["actual ticket qty for inbox rollup : ",amt]) ;
    */
    return true;
  };
  
  let _testDepositFail = ( [s,depositOp,tezToPay,message] : [address,depositOp,nat,string]) : bool => {
    Test.set_source(s);
    let errorMap : map<string,string> = Map.literal(list([
      ["0", "Enter a positive and not null amount"],
      ["1", "Invalid rollup address!"],
      ["2", "Invalid FA1.2 address!"],
      ["3", "User needs to provide at least 'amountToTransfer' mutez"],
      ["4", "We only accept tickets we created!"],
      ["5", "Cannot find the caller implicit account contract"],
      ["6", "The ticket does not contain a valid ticketType"],
      ["7","The contract does not exist or is not a valid fa1.2 contract"]
    ]));
    Test.log("Testing error to fail : "+ Option.unopt(Map.find_opt(message,errorMap)));
    return assert_failure(Test.transfer_to_contract(contr, (Deposit(depositOp)), tezToPay * (1 as tez)),message);
  };
  
  //********** TESTS *************/
  

  //XTZ deposit
  let xtzOp : xtzOp = {
        amountToTransfer: 42 as nat,
        rollupAddress: rollupAddress,
        l2Address: sender2};
  
  let testSender1Deposit42XTZToSender2 = _testDeposit(sender1,XTZ_OP(xtzOp),42 as nat);
  
  let xtzOp1 : xtzOp = {...xtzOp,amountToTransfer:0 as nat};
  let testSender1DepositBadAmount = _testDepositFail(sender1,XTZ_OP(xtzOp1),0 as nat,"0");
  
  let xtzOp2 : xtzOp = {...xtzOp1,amountToTransfer:42 as nat};
  let testSender1DepositNotEnoughXTZ = _testDepositFail(sender1,XTZ_OP(xtzOp2),0 as nat,"3");

  let xtzOp3 : xtzOp = {...xtzOp2,rollupAddress:sender2};
  let testSender1DepositInvalidRollupAddress = _testDepositFail(sender1,XTZ_OP(xtzOp3),42 as nat,"1");

  //FA1.2 deposit
  let fa12Op : fa12Op = {
    fa12Address: fa12Address,
    amountToTransfer: 42 as nat,
    rollupAddress: rollupAddress,
    l2Address: sender2
  };

  let testSender1Deposit42CTEZToSender2 = _testDeposit(sender1,FA12_OP(fa12Op),0 as nat);
  //TO CONTINUE



  //withdraw
